

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>rdflib.term &mdash; sssom-py 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> sssom-py
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">sssom-py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli_usage.html">SSSOM CLI usage</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">sssom-py</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>rdflib.term</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for rdflib.term</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines the different types of terms. Terms are the kinds of</span>
<span class="sd">objects that can appear in a quoted/asserted triple. This includes those</span>
<span class="sd">that are core to RDF:</span>

<span class="sd">* :class:`Blank Nodes &lt;rdflib.term.BNode&gt;`</span>
<span class="sd">* :class:`URI References &lt;rdflib.term.URIRef&gt;`</span>
<span class="sd">* :class:`Literals &lt;rdflib.term.Literal&gt;` (which consist of a literal value,datatype and language tag)</span>

<span class="sd">Those that extend the RDF model into N3:</span>

<span class="sd">* :class:`Formulae &lt;rdflib.graph.QuotedGraph&gt;`</span>
<span class="sd">* :class:`Universal Quantifications (Variables) &lt;rdflib.term.Variable&gt;`</span>

<span class="sd">And those that are primarily for matching against &#39;Nodes&#39; in the</span>
<span class="sd">underlying Graph:</span>

<span class="sd">* REGEX Expressions</span>
<span class="sd">* Date Ranges</span>
<span class="sd">* Numerical Ranges</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="c1"># from __future__ import unicode_literals</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;bind&#39;</span><span class="p">,</span>

    <span class="s1">&#39;Node&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Identifier&#39;</span><span class="p">,</span>

    <span class="s1">&#39;URIRef&#39;</span><span class="p">,</span>
    <span class="s1">&#39;BNode&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Literal&#39;</span><span class="p">,</span>

    <span class="s1">&#39;Variable&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Statement&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">import</span> <span class="nn">xml.dom.minidom</span>

<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span> <span class="nn">re</span> <span class="kn">import</span> <span class="n">sub</span><span class="p">,</span> <span class="nb">compile</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">unicodedata</span> <span class="kn">import</span> <span class="n">category</span>

<span class="kn">from</span> <span class="nn">isodate</span> <span class="kn">import</span> <span class="n">parse_time</span><span class="p">,</span> <span class="n">parse_date</span><span class="p">,</span> <span class="n">parse_datetime</span><span class="p">,</span> <span class="n">Duration</span><span class="p">,</span> <span class="n">parse_duration</span><span class="p">,</span> <span class="n">duration_isoformat</span>
<span class="kn">from</span> <span class="nn">binascii</span> <span class="kn">import</span> <span class="n">hexlify</span><span class="p">,</span> <span class="n">unhexlify</span>

<span class="kn">import</span> <span class="nn">rdflib</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">PY2</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">PY3</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">b</span>
<span class="kn">from</span> <span class="nn">rdflib.compat</span> <span class="kn">import</span> <span class="n">long_type</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">string_types</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">text_type</span>
<span class="kn">from</span> <span class="nn">six.moves.urllib.parse</span> <span class="kn">import</span> <span class="n">urldefrag</span>
<span class="kn">from</span> <span class="nn">six.moves.urllib.parse</span> <span class="kn">import</span> <span class="n">urljoin</span>
<span class="kn">from</span> <span class="nn">six.moves.urllib.parse</span> <span class="kn">import</span> <span class="n">urlparse</span>

<span class="n">skolem_genid</span> <span class="o">=</span> <span class="s2">&quot;/.well-known/genid/&quot;</span>
<span class="n">rdflib_skolem_genid</span> <span class="o">=</span> <span class="s2">&quot;/.well-known/genid/rdflib/&quot;</span>
<span class="n">skolems</span> <span class="o">=</span> <span class="p">{}</span>


<span class="n">_invalid_uri_chars</span> <span class="o">=</span> <span class="s1">&#39;&lt;&gt;&quot; </span><span class="si">{}</span><span class="s1">|</span><span class="se">\\</span><span class="s1">^`&#39;</span>


<span class="k">def</span> <span class="nf">_is_valid_uri</span><span class="p">(</span><span class="n">uri</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">256</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">_invalid_uri_chars</span><span class="p">,</span> <span class="n">uri</span><span class="p">))</span>


<span class="n">_lang_tag_regex</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="s1">&#39;^[a-zA-Z]+(?:-[a-zA-Z0-9]+)*$&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_valid_langtag</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">_lang_tag_regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_is_valid_unicode</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Verify that the provided value can be converted into a Python</span>
<span class="sd">    unicode object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="n">coding_func</span><span class="p">,</span> <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;decode&#39;</span><span class="p">),</span> <span class="s1">&#39;utf-8&#39;</span>
    <span class="k">elif</span> <span class="n">PY3</span><span class="p">:</span>
        <span class="n">coding_func</span><span class="p">,</span> <span class="n">param</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coding_func</span><span class="p">,</span> <span class="n">param</span> <span class="o">=</span> <span class="n">unicode</span><span class="p">,</span> <span class="n">value</span>

    <span class="c1"># try to convert value into unicode</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">coding_func</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">UnicodeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Node in the Graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>


<span class="k">class</span> <span class="nc">Identifier</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">text_type</span><span class="p">):</span>  <span class="c1"># allow Identifiers to be Nodes in the Graph</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See http://www.w3.org/2002/07/rdf-identifer-terminology/</span>
<span class="sd">    regarding choice of terminology.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A &quot;semantic&quot;/interpreted equality function,</span>
<span class="sd">        by default, same as __eq__&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">neq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A &quot;semantic&quot;/interpreted not equal function,</span>
<span class="sd">        by default, same as __ne__&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__ne__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equality for Nodes.</span>

<span class="sd">        &gt;&gt;&gt; BNode(&quot;foo&quot;)==None</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; BNode(&quot;foo&quot;)==URIRef(&quot;foo&quot;)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; URIRef(&quot;foo&quot;)==BNode(&quot;foo&quot;)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; BNode(&quot;foo&quot;)!=URIRef(&quot;foo&quot;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; URIRef(&quot;foo&quot;)!=BNode(&quot;foo&quot;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Variable(&#39;a&#39;)!=URIRef(&#39;a&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Variable(&#39;a&#39;)!=Variable(&#39;a&#39;)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">text_type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This implements ordering for Nodes,</span>

<span class="sd">        This tries to implement this:</span>
<span class="sd">        http://www.w3.org/TR/sparql11-query/#modOrderBy</span>

<span class="sd">        Variables are not included in the SPARQL list, but</span>
<span class="sd">        they are greater than BNodes and smaller than everything else</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># everything bigger than None</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">text_type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_ORDERING</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="n">_ORDERING</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)]</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Nothing is less than None</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">text_type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_ORDERING</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">_ORDERING</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)]</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="c1"># use parent&#39;s hash for efficiency reasons</span>
    <span class="c1"># clashes of &#39;foo&#39;, URIRef(&#39;foo&#39;) and Literal(&#39;foo&#39;) are typically so rare</span>
    <span class="c1"># that they don&#39;t justify additional overhead. Notice that even in case of</span>
    <span class="c1"># clash __eq__ is still the fallback and very quick in those cases.</span>
    <span class="fm">__hash__</span> <span class="o">=</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__hash__</span>


<span class="k">class</span> <span class="nc">URIRef</span><span class="p">(</span><span class="n">Identifier</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RDF URI Reference: http://www.w3.org/TR/rdf-concepts/#section-Graph-URIref</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ends_in_hash</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">urljoin</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">allow_fragments</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ends_in_hash</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">+=</span> <span class="s2">&quot;#&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_valid_uri</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> does not look like a valid URI, trying to serialize this will break.&#39;</span><span class="o">%</span><span class="n">value</span><span class="p">)</span>


        <span class="k">try</span><span class="p">:</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rt</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace_manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This will do a limited check for valid URIs,</span>
<span class="sd">        essentially just making sure that the string includes no illegal</span>
<span class="sd">        characters (``&lt;, &gt;, &quot;, {, }, |, \\, `, ^``)</span>

<span class="sd">        :param namespace_manager: if not None, will be used to make up</span>
<span class="sd">             a prefixed name</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_valid_uri</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot; does not look like a valid URI, I cannot serialize this as N3/Turtle. Perhaps you wanted to urlencode it?&#39;</span><span class="o">%</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">namespace_manager</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">namespace_manager</span><span class="o">.</span><span class="n">normalizeUri</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">defrag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;#&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">url</span><span class="p">,</span> <span class="n">frag</span> <span class="o">=</span> <span class="n">urldefrag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">URIRef</span><span class="p">,</span> <span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),))</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">)</span>

    <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">URIRef</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="s2">&quot;rdflib.term.URIRef&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">URIRef</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">other</span> <span class="o">+</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">%</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">de_skolemize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a Blank Node from a skolem URI, in accordance</span>
<span class="sd">        with http://www.w3.org/TR/rdf11-concepts/#section-skolemization.</span>
<span class="sd">        This function accepts only rdflib type skolemization, to provide</span>
<span class="sd">        a round-tripping within the system.</span>

<span class="sd">        .. versionadded:: 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RDFLibGenid</span><span class="p">):</span>
            <span class="n">parsed_uri</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BNode</span><span class="p">(</span>
                <span class="n">value</span><span class="o">=</span><span class="n">parsed_uri</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">rdflib_skolem_genid</span><span class="p">):])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Genid</span><span class="p">):</span>
            <span class="n">bnode_id</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span>
            <span class="k">if</span> <span class="n">bnode_id</span> <span class="ow">in</span> <span class="n">skolems</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">skolems</span><span class="p">[</span><span class="n">bnode_id</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retval</span> <span class="o">=</span> <span class="n">BNode</span><span class="p">()</span>
                <span class="n">skolems</span><span class="p">[</span><span class="n">bnode_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">retval</span>
                <span class="k">return</span> <span class="n">retval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&gt; is not a skolem URI&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Genid</span><span class="p">(</span><span class="n">URIRef</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_external_skolem</span><span class="p">(</span><span class="n">uri</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">uri</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>
        <span class="n">parsed_uri</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>
        <span class="n">gen_id</span> <span class="o">=</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">skolem_genid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gen_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">RDFLibGenid</span><span class="p">(</span><span class="n">Genid</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_rdflib_skolem</span><span class="p">(</span><span class="n">uri</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">uri</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>
        <span class="n">parsed_uri</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">params</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> \
                <span class="ow">or</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">query</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> \
                <span class="ow">or</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">fragment</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">gen_id</span> <span class="o">=</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">rdflib_skolem_genid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gen_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_unique_id</span><span class="p">():</span>
    <span class="c1"># Used to read: &quot;&quot;&quot;Create a (hopefully) unique prefix&quot;&quot;&quot;</span>
    <span class="c1"># now retained merely to leave interal API unchanged.</span>
    <span class="c1"># From BNode.__new__() below ...</span>
    <span class="c1">#</span>
    <span class="c1"># acceptable bnode value range for RDF/XML needs to be</span>
    <span class="c1"># something that can be serialzed as a nodeID for N3</span>
    <span class="c1">#</span>
    <span class="c1"># BNode identifiers must be valid NCNames&quot; _:[A-Za-z][A-Za-z0-9]*</span>
    <span class="c1"># http://www.w3.org/TR/2004/REC-rdf-testcases-20040210/#nodeID</span>
    <span class="k">return</span> <span class="s2">&quot;N&quot;</span>  <span class="c1"># ensure that id starts with a letter</span>


<span class="k">def</span> <span class="nf">_serial_number_generator</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates UUID4-based but ncname-compliant identifiers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">uuid</span> <span class="kn">import</span> <span class="n">uuid4</span>

    <span class="k">def</span> <span class="nf">_generator</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span>

    <span class="k">return</span> <span class="n">_generator</span>


<span class="k">class</span> <span class="nc">BNode</span><span class="p">(</span><span class="n">Identifier</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Blank Node: http://www.w3.org/TR/rdf-concepts/#section-blank-nodes</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">_sn_gen</span><span class="o">=</span><span class="n">_serial_number_generator</span><span class="p">(),</span> <span class="n">_prefix</span><span class="o">=</span><span class="n">_unique_id</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # only store implementations should pass in a value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># so that BNode values do not collide with ones created with</span>
            <span class="c1"># a different instance of this module at some other time.</span>
            <span class="n">node_id</span> <span class="o">=</span> <span class="n">_sn_gen</span><span class="p">()</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_prefix</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: check that value falls within acceptable bnode value range</span>
            <span class="c1"># for RDF/XML needs to be something that can be serialzed</span>
            <span class="c1"># as a nodeID for N3 ??  Unless we require these</span>
            <span class="c1"># constraints be enforced elsewhere?</span>
            <span class="k">pass</span>  <span class="c1"># assert is_ncname(text_type(value)), &quot;BNode identifiers</span>
            <span class="c1"># must be valid NCNames&quot; _:[A-Za-z][A-Za-z0-9]*</span>
            <span class="c1"># http://www.w3.org/TR/2004/REC-rdf-testcases-20040210/#nodeID</span>
        <span class="k">return</span> <span class="n">Identifier</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace_manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;_:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">BNode</span><span class="p">,</span> <span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),))</span>

    <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">BNode</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="s2">&quot;rdflib.term.BNode&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">(&#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">skolemize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">authority</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basepath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a URIRef &quot;skolem&quot; representation of the BNode, in accordance</span>
<span class="sd">        with http://www.w3.org/TR/rdf11-concepts/#section-skolemization</span>

<span class="sd">        .. versionadded:: 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">authority</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">authority</span> <span class="o">=</span> <span class="s2">&quot;http://rdlib.net/&quot;</span>
        <span class="k">if</span> <span class="n">basepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basepath</span> <span class="o">=</span> <span class="n">rdflib_skolem_genid</span>
        <span class="n">skolem</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">basepath</span><span class="p">,</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">urljoin</span><span class="p">(</span><span class="n">authority</span><span class="p">,</span> <span class="n">skolem</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Literal</span><span class="p">(</span><span class="n">Identifier</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    RDF Literal: http://www.w3.org/TR/rdf-concepts/#section-Graph-Literal</span>

<span class="s2">    The lexical value of the literal is the unicode object</span>
<span class="s2">    The interpreted, datatyped value is available from .value</span>

<span class="s2">    Language tags must be valid according to :rfc:5646</span>

<span class="s2">    For valid XSD datatypes, the lexical form is optionally normalized</span>
<span class="s2">    at construction time. Default behaviour is set by rdflib.NORMALIZE_LITERALS</span>
<span class="s2">    and can be overridden by the normalize parameter to __new__</span>

<span class="s2">    Equality and hashing of Literals are done based on the lexical form, i.e.:</span>

<span class="s2">    &gt;&gt;&gt; from rdflib.namespace import XSD</span>

<span class="s2">    &gt;&gt;&gt; Literal(&#39;01&#39;)!=Literal(&#39;1&#39;) # clear - strings differ</span>
<span class="s2">    True</span>

<span class="s2">    but with data-type they get normalized:</span>

<span class="s2">    &gt;&gt;&gt; Literal(&#39;01&#39;, datatype=XSD.integer)!=Literal(&#39;1&#39;, datatype=XSD.integer)</span>
<span class="s2">    False</span>

<span class="s2">    unless disabled:</span>

<span class="s2">    &gt;&gt;&gt; Literal(&#39;01&#39;, datatype=XSD.integer, normalize=False)!=Literal(&#39;1&#39;, datatype=XSD.integer)</span>
<span class="s2">    True</span>


<span class="s2">    Value based comparison is possible:</span>

<span class="s2">    &gt;&gt;&gt; Literal(&#39;01&#39;, datatype=XSD.integer).eq(Literal(&#39;1&#39;, datatype=XSD.float))</span>
<span class="s2">    True</span>

<span class="s2">    The eq method also provides limited support for basic python types:</span>

<span class="s2">    &gt;&gt;&gt; Literal(1).eq(1) # fine - int compatible with xsd:integer</span>
<span class="s2">    True</span>
<span class="s2">    &gt;&gt;&gt; Literal(&#39;a&#39;).eq(&#39;b&#39;) # fine - str compatible with plain-lit</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal(&#39;a&#39;, datatype=XSD.string).eq(&#39;a&#39;) # fine - str compatible with xsd:string</span>
<span class="s2">    True</span>
<span class="s2">    &gt;&gt;&gt; Literal(&#39;a&#39;).eq(1) # not fine, int incompatible with plain-lit</span>
<span class="s2">    NotImplemented</span>

<span class="s2">    Greater-than/less-than ordering comparisons are also done in value</span>
<span class="s2">    space, when compatible datatypes are used.  Incompatible datatypes</span>
<span class="s2">    are ordered by DT, or by lang-tag.  For other nodes the ordering</span>
<span class="s2">    is None &lt; BNode &lt; URIRef &lt; Literal</span>

<span class="s2">    Any comparison with non-rdflib Node are &quot;NotImplemented&quot;</span>
<span class="s2">    In PY2.X some stable order will be made up by python</span>

<span class="s2">    In PY3 this is an error.</span>

<span class="s2">    &gt;&gt;&gt; from rdflib import Literal, XSD</span>
<span class="s2">    &gt;&gt;&gt; lit2006 = Literal(&#39;2006-01-01&#39;,datatype=XSD.date)</span>
<span class="s2">    &gt;&gt;&gt; lit2006.toPython()</span>
<span class="s2">    datetime.date(2006, 1, 1)</span>
<span class="s2">    &gt;&gt;&gt; lit2006 &lt; Literal(&#39;2007-01-01&#39;,datatype=XSD.date)</span>
<span class="s2">    True</span>
<span class="s2">    &gt;&gt;&gt; Literal(datetime.utcnow()).datatype</span>
<span class="s2">    rdflib.term.URIRef(u&#39;http://www.w3.org/2001/XMLSchema#dateTime&#39;)</span>
<span class="s2">    &gt;&gt;&gt; Literal(1) &gt; Literal(2) # by value</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal(1) &gt; Literal(2.0) # by value</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal(&#39;1&#39;) &gt; Literal(1) # by DT</span>
<span class="s2">    True</span>
<span class="s2">    &gt;&gt;&gt; Literal(&#39;1&#39;) &lt; Literal(&#39;1&#39;) # by lexical form</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal(&#39;a&#39;, lang=&#39;en&#39;) &gt; Literal(&#39;a&#39;, lang=&#39;fr&#39;) # by lang-tag</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal(1) &gt; URIRef(&#39;foo&#39;) # by node-type</span>
<span class="s2">    True</span>

<span class="s2">    The &gt; &lt; operators will eat this NotImplemented and either make up</span>
<span class="s2">    an ordering (py2.x) or throw a TypeError (py3k):</span>

<span class="s2">    &gt;&gt;&gt; Literal(1).__gt__(2.0)</span>
<span class="s2">    NotImplemented</span>


<span class="s2">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">PY3</span><span class="p">:</span>
        <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;language&quot;</span><span class="p">,</span> <span class="s2">&quot;datatype&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="s2">&quot;_language&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;_datatype&quot;</span><span class="p">,</span> <span class="s2">&quot;_value&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_language&quot;</span><span class="p">,</span> <span class="s2">&quot;_datatype&quot;</span><span class="p">,</span> <span class="s2">&quot;_value&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">lang</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># no empty lang-tags in RDF</span>

        <span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span> <span class="k">if</span> <span class="n">normalize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">rdflib</span><span class="o">.</span><span class="n">NORMALIZE_LITERALS</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">datatype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;A Literal can only have one of lang or datatype, &quot;</span>
                <span class="s2">&quot;per http://www.w3.org/TR/rdf-concepts/#section-Graph-Literal&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_is_valid_langtag</span><span class="p">(</span><span class="n">lang</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is not a valid language tag!&quot;</span> <span class="o">%</span> <span class="n">lang</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">datatype</span><span class="p">:</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">datatype</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="c1"># create from another Literal instance</span>

            <span class="n">lang</span> <span class="o">=</span> <span class="n">lang</span> <span class="ow">or</span> <span class="n">lexical_or_value</span><span class="o">.</span><span class="n">language</span>
            <span class="k">if</span> <span class="n">datatype</span><span class="p">:</span>
                <span class="c1"># override datatype</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">_castLexicalToPython</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">datatype</span> <span class="o">=</span> <span class="n">lexical_or_value</span><span class="o">.</span><span class="n">datatype</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">lexical_or_value</span><span class="o">.</span><span class="n">value</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">PY3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
                <span class="c1"># passed a string</span>
                <span class="c1"># try parsing lexical form of datatyped literal</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">_castLexicalToPython</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="n">_value</span><span class="p">,</span> <span class="n">_datatype</span> <span class="o">=</span> <span class="n">_castPythonToLiteral</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_is_valid_unicode</span><span class="p">(</span><span class="n">_value</span><span class="p">):</span>
                    <span class="n">lexical_or_value</span> <span class="o">=</span> <span class="n">_value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># passed some python object</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">lexical_or_value</span>
            <span class="n">_value</span><span class="p">,</span> <span class="n">_datatype</span> <span class="o">=</span> <span class="n">_castPythonToLiteral</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span>

            <span class="n">datatype</span> <span class="o">=</span> <span class="n">datatype</span> <span class="ow">or</span> <span class="n">_datatype</span>
            <span class="k">if</span> <span class="n">_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lexical_or_value</span> <span class="o">=</span> <span class="n">_value</span>
            <span class="k">if</span> <span class="n">datatype</span><span class="p">:</span>
                <span class="n">lang</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">PY3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
            <span class="n">lexical_or_value</span> <span class="o">=</span> <span class="n">lexical_or_value</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lexical_or_value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lexical_or_value</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

        <span class="n">inst</span><span class="o">.</span><span class="n">_language</span> <span class="o">=</span> <span class="n">lang</span>
        <span class="n">inst</span><span class="o">.</span><span class="n">_datatype</span> <span class="o">=</span> <span class="n">datatype</span>
        <span class="n">inst</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">inst</span>

    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new literal with a normalised lexical representation</span>
<span class="sd">        of this literal</span>
<span class="sd">        &gt;&gt;&gt; from rdflib import XSD</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;01&quot;, datatype=XSD.integer, normalize=False).normalize()</span>
<span class="sd">        rdflib.term.Literal(u&#39;1&#39;, datatype=rdflib.term.URIRef(u&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        Illegal lexical forms for the datatype given are simply passed on</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;a&quot;, datatype=XSD.integer, normalize=False)</span>
<span class="sd">        rdflib.term.Literal(u&#39;a&#39;, datatype=rdflib.term.URIRef(u&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">language</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_language</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">datatype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_datatype</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Literal</span><span class="p">,</span> <span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">),)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_language</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;language&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datatype</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;datatype&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; Literal(1) + 1</span>
<span class="sd">        rdflib.term.Literal(u&#39;2&#39;, datatype=rdflib.term.URIRef(u&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;1&quot;) + &quot;1&quot;</span>
<span class="sd">        rdflib.term.Literal(u&#39;11&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if no val is supplied, return this Literal</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># convert the val to a Literal, if it isn&#39;t already one</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># if the datatypes are the same, just add the Python values and convert back</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">toPython</span><span class="p">()</span> <span class="o">+</span> <span class="n">val</span><span class="o">.</span><span class="n">toPython</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">)</span>
        <span class="c1"># if the datatypes are not the same but are both numeric, add the Python values and strip off decimal junk</span>
        <span class="c1"># (i.e. tiny numbers (more than 17 decimal places) and trailing zeros) and return as a decimal</span>
        <span class="k">elif</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span>
                <span class="ow">and</span>
                <span class="n">val</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span>
                <span class="n">Decimal</span><span class="p">(</span>
                    <span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">round</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">toPython</span><span class="p">())</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">toPython</span><span class="p">()),</span> <span class="mi">15</span><span class="p">))</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">datatype</span><span class="o">=</span><span class="n">_XSD_DECIMAL</span>
            <span class="p">)</span>
        <span class="c1"># in all other cases, perform string concatenation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="c1"># if the original datatype is string-like, use that</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_STRING_LITERAL_TYPES</span><span class="p">:</span>
                <span class="n">new_datatype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span>
            <span class="c1"># if not, use string</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_datatype</span> <span class="o">=</span> <span class="n">_XSD_STRING</span>

            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="n">new_datatype</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the Literal &quot;True&quot;</span>
<span class="sd">        This is used for if statements, bool(literal), etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
        <span class="n">__nonzero__</span> <span class="o">=</span> <span class="fm">__bool__</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; (- Literal(1))</span>
<span class="sd">        rdflib.term.Literal(u&#39;-1&#39;, datatype=rdflib.term.URIRef(u&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>
<span class="sd">        &gt;&gt;&gt; (- Literal(10.5))</span>
<span class="sd">        rdflib.term.Literal(u&#39;-10.5&#39;, datatype=rdflib.term.URIRef(u&#39;http://www.w3.org/2001/XMLSchema#double&#39;))</span>
<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; (- Literal(&quot;1&quot;, datatype=XSD.integer))</span>
<span class="sd">        rdflib.term.Literal(u&#39;-1&#39;, datatype=rdflib.term.URIRef(u&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        &gt;&gt;&gt; (- Literal(&quot;1&quot;))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">        TypeError: Not a number; rdflib.term.Literal(u&#39;1&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long_type</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__neg__</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a number; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; (+ Literal(1))</span>
<span class="sd">        rdflib.term.Literal(u&#39;1&#39;, datatype=rdflib.term.URIRef(u&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>
<span class="sd">        &gt;&gt;&gt; (+ Literal(-1))</span>
<span class="sd">        rdflib.term.Literal(u&#39;-1&#39;, datatype=rdflib.term.URIRef(u&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>
<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; (+ Literal(&quot;-1&quot;, datatype=XSD.integer))</span>
<span class="sd">        rdflib.term.Literal(u&#39;-1&#39;, datatype=rdflib.term.URIRef(u&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        &gt;&gt;&gt; (+ Literal(&quot;1&quot;))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">        TypeError: Not a number; rdflib.term.Literal(u&#39;1&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long_type</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__pos__</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a number; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; abs(Literal(-1))</span>
<span class="sd">        rdflib.term.Literal(u&#39;1&#39;, datatype=rdflib.term.URIRef(u&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; abs( Literal(&quot;-1&quot;, datatype=XSD.integer))</span>
<span class="sd">        rdflib.term.Literal(u&#39;1&#39;, datatype=rdflib.term.URIRef(u&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        &gt;&gt;&gt; abs(Literal(&quot;1&quot;))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">        TypeError: Not a number; rdflib.term.Literal(u&#39;1&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long_type</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__abs__</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a number; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; ~(Literal(-1))</span>
<span class="sd">        rdflib.term.Literal(u&#39;0&#39;, datatype=rdflib.term.URIRef(u&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; ~( Literal(&quot;-1&quot;, datatype=XSD.integer))</span>
<span class="sd">        rdflib.term.Literal(u&#39;0&#39;, datatype=rdflib.term.URIRef(u&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        Not working:</span>

<span class="sd">        &gt;&gt;&gt; ~(Literal(&quot;1&quot;))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">        TypeError: Not a number; rdflib.term.Literal(u&#39;1&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long_type</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__invert__</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a number; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        This implements ordering for Literals,</span>
<span class="sd">        the other comparison methods delegate here</span>

<span class="sd">        This tries to implement this:</span>
<span class="sd">        http://www.w3.org/TR/sparql11-query/#modOrderBy</span>

<span class="sd">        In short, Literals with compatible data-types are ordered in value</span>
<span class="sd">        space, i.e.</span>
<span class="sd">        &gt;&gt;&gt; from rdflib import XSD</span>

<span class="sd">        &gt;&gt;&gt; Literal(1) &gt; Literal(2) # int/int</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Literal(2.0) &gt; Literal(1) # double/int</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; from decimal import Decimal</span>
<span class="sd">        &gt;&gt;&gt; Literal(Decimal(&quot;3.3&quot;)) &gt; Literal(2.0) # decimal/double</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(Decimal(&quot;3.3&quot;)) &lt; Literal(4.0) # decimal/double</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(&#39;b&#39;) &gt; Literal(&#39;a&#39;) # plain lit/plain lit</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(&#39;b&#39;) &gt; Literal(&#39;a&#39;, datatype=XSD.string) # plain lit/xsd:str</span>
<span class="sd">        True</span>

<span class="sd">        Incompatible datatype mismatches ordered by DT</span>

<span class="sd">        &gt;&gt;&gt; Literal(1) &gt; Literal(&quot;2&quot;) # int&gt;string</span>
<span class="sd">        False</span>

<span class="sd">        Langtagged literals by lang tag</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;a&quot;, lang=&quot;en&quot;) &gt; Literal(&quot;a&quot;, lang=&quot;fr&quot;)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Everything is greater than None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span> <span class="ow">and</span> \
                    <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>

            <span class="c1"># plain-literals and xsd:string literals</span>
            <span class="c1"># are &quot;the same&quot;</span>
            <span class="n">dtself</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">or</span> <span class="n">_XSD_STRING</span>
            <span class="n">dtother</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">or</span> <span class="n">_XSD_STRING</span>

            <span class="k">if</span> <span class="n">dtself</span> <span class="o">!=</span> <span class="n">dtother</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rdflib</span><span class="o">.</span><span class="n">DAWG_LITERAL_COLLATION</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">NotImplemented</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">dtself</span> <span class="o">&gt;</span> <span class="n">dtother</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">language</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">language</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">language</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_TOTAL_ORDER_CASTERS</span><span class="p">:</span>
                    <span class="n">caster</span> <span class="o">=</span> <span class="n">_TOTAL_ORDER_CASTERS</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)]</span>
                    <span class="k">return</span> <span class="n">caster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">caster</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">if</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="n">text_type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">text_type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="c1"># same language, same lexical form, check real dt</span>
            <span class="c1"># plain-literals come before xsd:string!</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span>

            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># they are the same</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Literal are the greatest!</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>  <span class="c1"># we can only compare to nodes</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Nothing is less than None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># all nodes are less-than Literals</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; Literal(&#39;2007-01-01T10:00:00&#39;, datatype=XSD.dateTime</span>
<span class="sd">        ...     ) &lt;= Literal(&#39;2007-01-01T10:00:00&#39;, datatype=XSD.dateTime)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">_comparable_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to decide which things are meaningful to</span>
<span class="sd">        rich-compare with this literal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">):</span>
                <span class="c1"># two datatyped literals</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">XSDToPython</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">XSDToPython</span><span class="p">:</span>
                    <span class="c1"># non XSD DTs must match</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># xsd:string may be compared with plain literals</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_STRING</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">)</span> <span class="ow">or</span> \
                        <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_STRING</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>

                <span class="c1"># if given lang-tag has to be case insensitive equal</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">language</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; a = {Literal(&#39;1&#39;, datatype=XSD.integer):&#39;one&#39;}</span>
<span class="sd">        &gt;&gt;&gt; Literal(&#39;1&#39;, datatype=XSD.double) in a</span>
<span class="sd">        False</span>


<span class="sd">        &quot;Called for the key object for dictionary operations,</span>
<span class="sd">        and by the built-in function hash(). Should return</span>
<span class="sd">        a 32-bit integer usable as a hash value for</span>
<span class="sd">        dictionary operations. The only required property</span>
<span class="sd">        is that objects which compare equal have the same</span>
<span class="sd">        hash value; it is advised to somehow mix together</span>
<span class="sd">        (e.g., using exclusive or) the hash values for the</span>
<span class="sd">        components of the object that also play a part in</span>
<span class="sd">        comparison of objects.&quot; -- 3.4.1 Basic customization (Python)</span>

<span class="sd">        &quot;Two literals are equal if and only if all of the following hold:</span>
<span class="sd">        * The strings of the two lexical forms compare equal, character by</span>
<span class="sd">        character.</span>
<span class="sd">        * Either both or neither have language tags.</span>
<span class="sd">        * The language tags, if any, compare equal.</span>
<span class="sd">        * Either both or neither have datatype URIs.</span>
<span class="sd">        * The two datatype URIs, if any, compare equal, character by</span>
<span class="sd">        character.&quot;</span>
<span class="sd">        -- 6.5.1 Literal Equality (RDF: Concepts and Abstract Syntax)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># don&#39;t use super()... for efficiency reasons, see Identifier.__hash__</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Literals are only equal to other literals.</span>

<span class="sd">        &quot;Two literals are equal if and only if all of the following hold:</span>
<span class="sd">        * The strings of the two lexical forms compare equal, character by character.</span>
<span class="sd">        * Either both or neither have language tags.</span>
<span class="sd">        * The language tags, if any, compare equal.</span>
<span class="sd">        * Either both or neither have datatype URIs.</span>
<span class="sd">        * The two datatype URIs, if any, compare equal, character by character.&quot;</span>
<span class="sd">        -- 6.5.1 Literal Equality (RDF: Concepts and Abstract Syntax)</span>

<span class="sd">        &gt;&gt;&gt; Literal(&quot;1&quot;, datatype=URIRef(&quot;foo&quot;)) == Literal(&quot;1&quot;, datatype=URIRef(&quot;foo&quot;))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;1&quot;, datatype=URIRef(&quot;foo&quot;)) == Literal(&quot;1&quot;, datatype=URIRef(&quot;foo2&quot;))</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; Literal(&quot;1&quot;, datatype=URIRef(&quot;foo&quot;)) == Literal(&quot;2&quot;, datatype=URIRef(&quot;foo&quot;))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;1&quot;, datatype=URIRef(&quot;foo&quot;)) == &quot;asdf&quot;</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; from rdflib import XSD</span>
<span class="sd">        &gt;&gt;&gt; Literal(&#39;2007-01-01&#39;, datatype=XSD.date) == Literal(&#39;2007-01-01&#39;, datatype=XSD.date)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(&#39;2007-01-01&#39;, datatype=XSD.date) == date(2007, 1, 1)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;one&quot;, lang=&quot;en&quot;) == Literal(&quot;one&quot;, lang=&quot;en&quot;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;hast&quot;, lang=&#39;en&#39;) == Literal(&quot;hast&quot;, lang=&#39;de&#39;)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;1&quot;, datatype=XSD.integer) == Literal(1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;1&quot;, datatype=XSD.integer) == Literal(&quot;01&quot;, datatype=XSD.integer)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">language</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">language</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare the value of this literal with something else</span>

<span class="sd">        Either, with the value of another literal</span>
<span class="sd">        comparisons are then done in literal &quot;value space&quot;,</span>
<span class="sd">        and according to the rules of XSD subtype-substitution/type-promotion</span>

<span class="sd">        OR, with a python object:</span>

<span class="sd">        basestring objects can be compared with plain-literals,</span>
<span class="sd">        or those with datatype xsd:string</span>

<span class="sd">        bool objects with xsd:boolean</span>

<span class="sd">        a int, long or float with numeric xsd types</span>

<span class="sd">        isodate date,time,datetime objects with xsd:date,xsd:time or xsd:datetime</span>

<span class="sd">        Any other operations returns NotImplemented</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span>  \
                    <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;I cannot know that these two lexical forms do not map to the same value: </span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">language</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">dtself</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">or</span> <span class="n">_XSD_STRING</span>
            <span class="n">dtother</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">or</span> <span class="n">_XSD_STRING</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">dtself</span> <span class="o">==</span> <span class="n">_XSD_STRING</span> <span class="ow">and</span> <span class="n">dtother</span> <span class="o">==</span> <span class="n">_XSD_STRING</span><span class="p">):</span>
                <span class="c1"># string/plain literals, compare on lexical form</span>
                <span class="k">return</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dtself</span> <span class="o">!=</span> <span class="n">dtother</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rdflib</span><span class="o">.</span><span class="n">DAWG_LITERAL_COLLATION</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;I don&#39;t know how to compare literals with datatypes </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># matching non-string DTs now - do we compare values or</span>
            <span class="c1"># lexical form first?  comparing two ints is far quicker -</span>
            <span class="c1"># maybe there are counter examples</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_RDF_XMLLITERAL</span><span class="p">,</span> <span class="n">_RDF_HTMLLITERAL</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">_isEqualXMLNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_STRING</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># string value space=lexical space</span>

                <span class="c1"># matching DTs, but not matching, we cannot compare!</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;I cannot know that these two lexical forms do not map to the same value: </span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># no non-Literal nodes are equal to a literal</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="c1"># only plain-literals can be directly compared to strings</span>

            <span class="c1"># TODO: Is &quot;blah&quot;@en eq &quot;blah&quot; ?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_STRING</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">other</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long_type</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">time</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_XSD_DATETIME</span><span class="p">,</span> <span class="n">_XSD_DATE</span><span class="p">,</span> <span class="n">_XSD_TIME</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">timedelta</span><span class="p">,</span> <span class="n">Duration</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_XSD_DURATION</span><span class="p">,</span> <span class="n">_XSD_DAYTIMEDURATION</span><span class="p">,</span> <span class="n">_XSD_YEARMONTHDURATION</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_BOOLEAN</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">neq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace_manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a representation in the N3 format.</span>

<span class="sd">        Examples::</span>

<span class="sd">            &gt;&gt;&gt; Literal(&quot;foo&quot;).n3()</span>
<span class="sd">            u&#39;&quot;foo&quot;&#39;</span>

<span class="sd">        Strings with newlines or triple-quotes::</span>

<span class="sd">            &gt;&gt;&gt; Literal(&quot;foo\nbar&quot;).n3()</span>
<span class="sd">            u&#39;&quot;&quot;&quot;foo\nbar&quot;&quot;&quot;&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(&quot;&#39;&#39;\&#39;&quot;).n3()</span>
<span class="sd">            u&#39;&quot;\&#39;\&#39;\&#39;&quot;&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(&#39;&quot;&quot;&quot;&#39;).n3()</span>
<span class="sd">            u&#39;&quot;\\&quot;\\&quot;\\&quot;&quot;&#39;</span>

<span class="sd">        Language::</span>

<span class="sd">            &gt;&gt;&gt; Literal(&quot;hello&quot;, lang=&quot;en&quot;).n3()</span>
<span class="sd">            u&#39;&quot;hello&quot;@en&#39;</span>

<span class="sd">        Datatypes::</span>

<span class="sd">            &gt;&gt;&gt; Literal(1).n3()</span>
<span class="sd">            u&#39;&quot;1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.0).n3()</span>
<span class="sd">            u&#39;&quot;1.0&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(True).n3()</span>
<span class="sd">            u&#39;&quot;true&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;&#39;</span>

<span class="sd">        Datatype and language isn&#39;t allowed (datatype takes precedence)::</span>

<span class="sd">            &gt;&gt;&gt; Literal(1, lang=&quot;en&quot;).n3()</span>
<span class="sd">            u&#39;&quot;1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;&#39;</span>

<span class="sd">        Custom datatype::</span>

<span class="sd">            &gt;&gt;&gt; footype = URIRef(&quot;http://example.org/ns#foo&quot;)</span>
<span class="sd">            &gt;&gt;&gt; Literal(&quot;1&quot;, datatype=footype).n3()</span>
<span class="sd">            u&#39;&quot;1&quot;^^&lt;http://example.org/ns#foo&gt;&#39;</span>

<span class="sd">        Passing a namespace-manager will use it to abbreviate datatype URIs:</span>

<span class="sd">            &gt;&gt;&gt; from rdflib import Graph</span>
<span class="sd">            &gt;&gt;&gt; Literal(1).n3(Graph().namespace_manager)</span>
<span class="sd">            u&#39;&quot;1&quot;^^xsd:integer&#39;</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">namespace_manager</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literal_n3</span><span class="p">(</span><span class="n">qname_callback</span><span class="o">=</span><span class="n">namespace_manager</span><span class="o">.</span><span class="n">normalizeUri</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literal_n3</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_literal_n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_plain</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">qname_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Using plain literal (shorthand) output::</span>
<span class="sd">            &gt;&gt;&gt; from rdflib.namespace import XSD</span>

<span class="sd">            &gt;&gt;&gt; Literal(1)._literal_n3(use_plain=True)</span>
<span class="sd">            u&#39;1&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.0)._literal_n3(use_plain=True)</span>
<span class="sd">            u&#39;1e+00&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.0, datatype=XSD.decimal)._literal_n3(use_plain=True)</span>
<span class="sd">            u&#39;1.0&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.0, datatype=XSD.float)._literal_n3(use_plain=True)</span>
<span class="sd">            u&#39;&quot;1.0&quot;^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(&quot;foo&quot;, datatype=XSD.string)._literal_n3(</span>
<span class="sd">            ...         use_plain=True)</span>
<span class="sd">            u&#39;&quot;foo&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(True)._literal_n3(use_plain=True)</span>
<span class="sd">            u&#39;true&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(False)._literal_n3(use_plain=True)</span>
<span class="sd">            u&#39;false&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.91)._literal_n3(use_plain=True)</span>
<span class="sd">            u&#39;1.91e+00&#39;</span>

<span class="sd">            Only limited precision available for floats:</span>
<span class="sd">            &gt;&gt;&gt; Literal(0.123456789)._literal_n3(use_plain=True)</span>
<span class="sd">            u&#39;1.234568e-01&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(&#39;0.123456789&#39;,</span>
<span class="sd">            ...     datatype=XSD.decimal)._literal_n3(use_plain=True)</span>
<span class="sd">            u&#39;0.123456789&#39;</span>

<span class="sd">        Using callback for datatype QNames::</span>

<span class="sd">            &gt;&gt;&gt; Literal(1)._literal_n3(</span>
<span class="sd">            ...         qname_callback=lambda uri: &quot;xsd:integer&quot;)</span>
<span class="sd">            u&#39;&quot;1&quot;^^xsd:integer&#39;</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">use_plain</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_PLAIN_LITERAL_TYPES</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If self is inf or NaN, we need a datatype</span>
                <span class="c1"># (there is no plain representation)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_INF_NAN_LITERAL_TYPES</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literal_n3</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">qname_callback</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literal_n3</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">qname_callback</span><span class="p">)</span>

                <span class="c1"># this is a bit of a mess -</span>
                <span class="c1"># in py &gt;=2.6 the string.format function makes this easier</span>
                <span class="c1"># we try to produce &quot;pretty&quot; output</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_DOUBLE</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">sub</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">.?0*e&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_DECIMAL</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span>
                    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;.0&#39;</span>
                    <span class="k">return</span> <span class="n">s</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_BOOLEAN</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="sa">u</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="sa">u</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span>

        <span class="n">encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quote_encode</span><span class="p">()</span>

        <span class="n">datatype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span>
        <span class="n">quoted_dt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">datatype</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">qname_callback</span><span class="p">:</span>
                <span class="n">quoted_dt</span> <span class="o">=</span> <span class="n">qname_callback</span><span class="p">(</span><span class="n">datatype</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">quoted_dt</span><span class="p">:</span>
                <span class="n">quoted_dt</span> <span class="o">=</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">datatype</span>
            <span class="k">if</span> <span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_INF_NAN_LITERAL_TYPES</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                        <span class="c1"># py string reps: float: &#39;inf&#39;, Decimal: &#39;Infinity&quot;</span>
                        <span class="c1"># both need to become &quot;INF&quot; in xsd datatypes</span>
                        <span class="n">encoded</span> <span class="o">=</span> <span class="n">encoded</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">,</span> <span class="s1">&#39;INF&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="s1">&#39;Infinity&#39;</span><span class="p">,</span> <span class="s1">&#39;INF&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                        <span class="n">encoded</span> <span class="o">=</span> <span class="n">encoded</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">,</span> <span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># if we can&#39;t cast to float something is wrong, but we can</span>
                    <span class="c1"># still serialize. Warn user about it</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Serializing weird numerical </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">language</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span>
        <span class="k">if</span> <span class="n">language</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">@</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">encoded</span><span class="p">,</span> <span class="n">language</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">datatype</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">^^</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">encoded</span><span class="p">,</span> <span class="n">quoted_dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">encoded</span>

    <span class="k">def</span> <span class="nf">_quote_encode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># This simpler encoding doesn&#39;t work; a newline gets encoded as &quot;\\n&quot;,</span>
        <span class="c1"># which is ok in sourcecode, but we want &quot;\n&quot;.</span>
        <span class="c1"># encoded = self.encode(&#39;unicode-escape&#39;).replace(</span>
        <span class="c1">#        &#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;&quot;&#39;,&#39;\\&quot;&#39;)</span>
        <span class="c1"># encoded = self.replace.replace(&#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;&quot;&#39;,&#39;\\&quot;&#39;)</span>

        <span class="c1"># NOTE: Could in theory chose quotes based on quotes appearing in the</span>
        <span class="c1"># string, i.e. &#39;&quot;&#39; and &quot;&#39;&quot;, but N3/turtle doesn&#39;t allow &quot;&#39;&quot;(?).</span>

        <span class="k">if</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># Triple quote this string.</span>
            <span class="n">encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\\\</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;&quot;&quot;&quot;&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="c1"># is this ok?</span>
                <span class="n">encoded</span> <span class="o">=</span> <span class="n">encoded</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&quot;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&quot;</span><span class="se">\\</span><span class="s1">&quot;</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">encoded</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span> <span class="ow">and</span> <span class="n">encoded</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">:</span>
                <span class="n">encoded</span> <span class="o">=</span> <span class="n">encoded</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span>

            <span class="k">return</span> <span class="s1">&#39;&quot;&quot;&quot;</span><span class="si">%s</span><span class="s1">&quot;&quot;&quot;&#39;</span> <span class="o">%</span> <span class="n">encoded</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">r&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">n&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\\\</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                        <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">r&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span><span class="p">(</span><span class="n">Literal</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;lang=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;datatype=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">Literal</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="s2">&quot;rdflib.term.Literal&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an appropriate python datatype derived from this RDF Literal</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">def</span> <span class="nf">_parseXML</span><span class="p">(</span><span class="n">xmlstring</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
        <span class="n">xmlstring</span> <span class="o">=</span> <span class="n">xmlstring</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span>
        <span class="s2">&quot;&lt;rdflibtoplevelelement&gt;</span><span class="si">%s</span><span class="s2">&lt;/rdflibtoplevelelement&gt;&quot;</span> <span class="o">%</span> <span class="n">xmlstring</span><span class="p">)</span>
    <span class="n">retval</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">retval</span>


<span class="k">def</span> <span class="nf">_parseHTML</span><span class="p">(</span><span class="n">htmltext</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">html5lib</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">html5lib</span><span class="o">.</span><span class="n">HTMLParser</span><span class="p">(</span>
            <span class="n">tree</span><span class="o">=</span><span class="n">html5lib</span><span class="o">.</span><span class="n">treebuilders</span><span class="o">.</span><span class="n">getTreeBuilder</span><span class="p">(</span><span class="s2">&quot;dom&quot;</span><span class="p">))</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parseFragment</span><span class="p">(</span><span class="n">htmltext</span><span class="p">)</span>
        <span class="n">retval</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">retval</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
            <span class="s2">&quot;HTML5 parser not available. Try installing&quot;</span> <span class="o">+</span>
            <span class="s2">&quot; html5lib &lt;http://code.google.com/p/html5lib&gt;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_writeXML</span><span class="p">(</span><span class="n">xmlnode</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xmlnode</span><span class="p">,</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">DocumentFragment</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">Document</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">childNodes</span> <span class="o">+=</span> <span class="n">xmlnode</span><span class="o">.</span><span class="n">childNodes</span>
        <span class="n">xmlnode</span> <span class="o">=</span> <span class="n">d</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">xmlnode</span><span class="o">.</span><span class="n">toxml</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
    <span class="c1"># for clean round-tripping, remove headers -- I have great and</span>
    <span class="c1"># specific worries that this will blow up later, but this margin</span>
    <span class="c1"># is too narrow to contain them</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="s1">&#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#39;</span><span class="p">)):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">38</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="s1">&#39;&lt;rdflibtoplevelelement&gt;&#39;</span><span class="p">)):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">23</span><span class="p">:</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">b</span><span class="p">(</span><span class="s1">&#39;&lt;rdflibtoplevelelement/&gt;&#39;</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">b</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span>


<span class="k">def</span> <span class="nf">_unhexlify</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="c1"># In Python 3.2, unhexlify does not support str (only bytes)</span>
    <span class="k">if</span> <span class="n">PY3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">unhexlify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_parseBoolean</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="n">true_accepted_values</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">]</span>
    <span class="n">false_accepted_values</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;false&#39;</span><span class="p">]</span>
    <span class="n">new_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">new_value</span> <span class="ow">in</span> <span class="n">true_accepted_values</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">new_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">false_accepted_values</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Parsing weird boolean, </span><span class="si">% r</span><span class="s1"> does not map to True or False&#39;</span> <span class="o">%</span> <span class="n">value</span><span class="p">,</span> <span class="n">category</span> <span class="o">=</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="c1"># Cannot import Namespace/XSD because of circular dependencies</span>
<span class="n">_XSD_PFX</span> <span class="o">=</span> <span class="s1">&#39;http://www.w3.org/2001/XMLSchema#&#39;</span>
<span class="n">_RDF_PFX</span> <span class="o">=</span> <span class="s1">&#39;http://www.w3.org/1999/02/22-rdf-syntax-ns#&#39;</span>

<span class="n">_RDF_XMLLITERAL</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_RDF_PFX</span> <span class="o">+</span> <span class="s1">&#39;XMLLiteral&#39;</span><span class="p">)</span>
<span class="n">_RDF_HTMLLITERAL</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_RDF_PFX</span> <span class="o">+</span> <span class="s1">&#39;HTML&#39;</span><span class="p">)</span>

<span class="n">_XSD_STRING</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span>

<span class="n">_XSD_FLOAT</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;float&#39;</span><span class="p">)</span>
<span class="n">_XSD_DOUBLE</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;double&#39;</span><span class="p">)</span>
<span class="n">_XSD_DECIMAL</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;decimal&#39;</span><span class="p">)</span>
<span class="n">_XSD_INTEGER</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;integer&#39;</span><span class="p">)</span>
<span class="n">_XSD_BOOLEAN</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;boolean&#39;</span><span class="p">)</span>

<span class="n">_XSD_DATETIME</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;dateTime&#39;</span><span class="p">)</span>
<span class="n">_XSD_DATE</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;date&#39;</span><span class="p">)</span>
<span class="n">_XSD_TIME</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="n">_XSD_DURATION</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;duration&#39;</span><span class="p">)</span>
<span class="n">_XSD_DAYTIMEDURATION</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;dayTimeDuration&#39;</span><span class="p">)</span>
<span class="n">_XSD_YEARMONTHDURATION</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;yearMonthDuration&#39;</span><span class="p">)</span>

<span class="n">_OWL_RATIONAL</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="s1">&#39;http://www.w3.org/2002/07/owl#rational&#39;</span><span class="p">)</span>
<span class="n">_XSD_HEXBINARY</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;hexBinary&#39;</span><span class="p">)</span>
<span class="c1"># TODO: gYearMonth, gYear, gMonthDay, gDay, gMonth</span>

<span class="n">_NUMERIC_LITERAL_TYPES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">_XSD_INTEGER</span><span class="p">,</span>
    <span class="n">_XSD_DECIMAL</span><span class="p">,</span>
    <span class="n">_XSD_DOUBLE</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;float&#39;</span><span class="p">),</span>

    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;byte&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;int&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;long&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;negativeInteger&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;nonNegativeInteger&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;nonPositiveInteger&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;positiveInteger&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;short&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedByte&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedInt&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedLong&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedShort&#39;</span><span class="p">),</span>

<span class="p">)</span>

<span class="c1"># these have &quot;native&quot; syntax in N3/SPARQL</span>
<span class="n">_PLAIN_LITERAL_TYPES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">_XSD_INTEGER</span><span class="p">,</span>
    <span class="n">_XSD_BOOLEAN</span><span class="p">,</span>
    <span class="n">_XSD_DOUBLE</span><span class="p">,</span>
    <span class="n">_XSD_DECIMAL</span><span class="p">,</span>
    <span class="n">_OWL_RATIONAL</span>
<span class="p">)</span>

<span class="c1"># these have special INF and NaN XSD representations</span>
<span class="n">_NUMERIC_INF_NAN_LITERAL_TYPES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;float&#39;</span><span class="p">),</span>
    <span class="n">_XSD_DOUBLE</span><span class="p">,</span>
    <span class="n">_XSD_DECIMAL</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># the following types need special treatment for reasonable sorting because</span>
<span class="c1"># certain instances can&#39;t be compared to each other. We treat this by</span>
<span class="c1"># partitioning and then sorting within those partitions.</span>
<span class="n">_TOTAL_ORDER_CASTERS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">datetime</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">value</span><span class="p">:</span> <span class="p">(</span>
        <span class="c1"># naive vs. aware</span>
        <span class="n">value</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">tzinfo</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">value</span>
    <span class="p">),</span>
    <span class="n">time</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">value</span><span class="p">:</span> <span class="p">(</span>
        <span class="c1"># naive vs. aware</span>
        <span class="n">value</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">tzinfo</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">value</span>
    <span class="p">),</span>
    <span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">Document</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">value</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">toxml</span><span class="p">(),</span>
<span class="p">}</span>


<span class="n">_STRING_LITERAL_TYPES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">_XSD_STRING</span><span class="p">,</span>
    <span class="n">_RDF_XMLLITERAL</span><span class="p">,</span>
    <span class="n">_RDF_HTMLLITERAL</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;normalizedString&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;token&#39;</span><span class="p">)</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">_py2literal</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pType</span><span class="p">,</span> <span class="n">castFunc</span><span class="p">,</span> <span class="n">dType</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">castFunc</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">castFunc</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">dType</span>
    <span class="k">elif</span> <span class="n">dType</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="n">dType</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_castPythonToLiteral</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">datatype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Casts a tuple of a python type and a special datatype URI to a tuple of the lexical value and a</span>
<span class="sd">    datatype URI (or None)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">pType</span><span class="p">,</span> <span class="n">dType</span><span class="p">),</span> <span class="n">castFunc</span> <span class="ow">in</span> <span class="n">_SpecificPythonToXSDRules</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pType</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dType</span> <span class="o">==</span> <span class="n">datatype</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_py2literal</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pType</span><span class="p">,</span> <span class="n">castFunc</span><span class="p">,</span> <span class="n">dType</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">pType</span><span class="p">,</span> <span class="p">(</span><span class="n">castFunc</span><span class="p">,</span> <span class="n">dType</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_GenericPythonToXSDRules</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_py2literal</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pType</span><span class="p">,</span> <span class="n">castFunc</span><span class="p">,</span> <span class="n">dType</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="kc">None</span>  <span class="c1"># TODO: is this right for the fall through case?</span>


<span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>

<span class="c1"># Mappings from Python types to XSD datatypes and back (borrowed from sparta)</span>
<span class="c1"># datetime instances are also instances of date... so we need to order these.</span>

<span class="c1"># SPARQL/Turtle/N3 has shortcuts for integer, double, decimal</span>
<span class="c1"># python has only float - to be in tune with sparql/n3/turtle</span>
<span class="c1"># we default to XSD.double for float literals</span>

<span class="c1"># python ints are promoted to longs when overflowing</span>
<span class="c1"># python longs have no limit</span>
<span class="c1"># both map to the abstract integer type,</span>
<span class="c1"># rather than some concrete bit-limited datatype</span>
<span class="n">_GenericPythonToXSDRules</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="n">string_types</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)),</span>
    <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_XSD_DOUBLE</span><span class="p">)),</span>
    <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">_XSD_BOOLEAN</span><span class="p">)),</span>
    <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_XSD_INTEGER</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">long_type</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_XSD_INTEGER</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_XSD_DECIMAL</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">datetime</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(),</span> <span class="n">_XSD_DATETIME</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(),</span> <span class="n">_XSD_DATE</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(),</span> <span class="n">_XSD_TIME</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">Duration</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">duration_isoformat</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">_XSD_DURATION</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">timedelta</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">duration_isoformat</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">_XSD_DAYTIMEDURATION</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">Document</span><span class="p">,</span> <span class="p">(</span><span class="n">_writeXML</span><span class="p">,</span> <span class="n">_RDF_XMLLITERAL</span><span class="p">)),</span>
    <span class="c1"># this is a bit dirty - by accident the html5lib parser produces</span>
    <span class="c1"># DocumentFragments, and the xml parser Documents, letting this</span>
    <span class="c1"># decide what datatype to use makes roundtripping easier, but it a</span>
    <span class="c1"># bit random</span>
    <span class="p">(</span><span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">DocumentFragment</span><span class="p">,</span> <span class="p">(</span><span class="n">_writeXML</span><span class="p">,</span> <span class="n">_RDF_HTMLLITERAL</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">Fraction</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_OWL_RATIONAL</span><span class="p">))</span>
<span class="p">]</span>

<span class="n">_SpecificPythonToXSDRules</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">((</span><span class="n">string_types</span><span class="p">,</span> <span class="n">_XSD_HEXBINARY</span><span class="p">),</span> <span class="n">hexlify</span><span class="p">),</span>
<span class="p">]</span>
<span class="k">if</span> <span class="n">PY3</span><span class="p">:</span>
    <span class="n">_SpecificPythonToXSDRules</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="nb">bytes</span><span class="p">,</span> <span class="n">_XSD_HEXBINARY</span><span class="p">),</span> <span class="n">hexlify</span><span class="p">))</span>

<span class="n">XSDToPython</span> <span class="o">=</span> <span class="p">{</span>
    <span class="kc">None</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># plain literals map directly to value space</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;time&#39;</span><span class="p">):</span> <span class="n">parse_time</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;date&#39;</span><span class="p">):</span> <span class="n">parse_date</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;gYear&#39;</span><span class="p">):</span> <span class="n">parse_date</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;gYearMonth&#39;</span><span class="p">):</span> <span class="n">parse_date</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;dateTime&#39;</span><span class="p">):</span> <span class="n">parse_datetime</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;duration&#39;</span><span class="p">):</span> <span class="n">parse_duration</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;dayTimeDuration&#39;</span><span class="p">):</span> <span class="n">parse_duration</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;yearMonthDuration&#39;</span><span class="p">):</span> <span class="n">parse_duration</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;hexBinary&#39;</span><span class="p">):</span> <span class="n">_unhexlify</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;string&#39;</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;normalizedString&#39;</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;token&#39;</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;language&#39;</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;boolean&#39;</span><span class="p">):</span> <span class="n">_parseBoolean</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;decimal&#39;</span><span class="p">):</span> <span class="n">Decimal</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;integer&#39;</span><span class="p">):</span> <span class="n">long_type</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;nonPositiveInteger&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;long&#39;</span><span class="p">):</span> <span class="n">long_type</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;nonNegativeInteger&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;negativeInteger&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;int&#39;</span><span class="p">):</span> <span class="n">long_type</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedLong&#39;</span><span class="p">):</span> <span class="n">long_type</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;positiveInteger&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;short&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedInt&#39;</span><span class="p">):</span> <span class="n">long_type</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;byte&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedShort&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedByte&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;float&#39;</span><span class="p">):</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;double&#39;</span><span class="p">):</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;base64Binary&#39;</span><span class="p">):</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;anyURI&#39;</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">_RDF_XMLLITERAL</span><span class="p">:</span> <span class="n">_parseXML</span><span class="p">,</span>
    <span class="n">_RDF_HTMLLITERAL</span><span class="p">:</span> <span class="n">_parseHTML</span>
<span class="p">}</span>

<span class="n">_toPythonMapping</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">_toPythonMapping</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">XSDToPython</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_castLexicalToPython</span><span class="p">(</span><span class="n">lexical</span><span class="p">,</span> <span class="n">datatype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map a lexical form to the value-space for the given datatype</span>
<span class="sd">    :returns: a python object for the value or ``None``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">convFunc</span> <span class="o">=</span> <span class="n">_toPythonMapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">datatype</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">convFunc</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">convFunc</span><span class="p">(</span><span class="n">lexical</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># not a valid lexical representation for this dt</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">convFunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># no conv func means 1-1 lexical&lt;-&gt;value-space mapping</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="n">lexical</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">text_type</span><span class="p">(</span><span class="n">lexical</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># no convFunc - unknown data-type</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="n">datatype</span><span class="p">,</span> <span class="n">pythontype</span><span class="p">,</span> <span class="n">constructor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lexicalizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">datatype_specific</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    register a new datatype&lt;-&gt;pythontype binding</span>

<span class="sd">    :param constructor: an optional function for converting lexical forms</span>
<span class="sd">                        into a Python instances, if not given the pythontype</span>
<span class="sd">                        is used directly</span>

<span class="sd">    :param lexicalizer: an optional function for converting python objects to</span>
<span class="sd">                        lexical form, if not given object.__str__ is used</span>

<span class="sd">    :param datatype_specific: makes the lexicalizer function be accessible</span>
<span class="sd">                              from the pair (pythontype, datatype) if set to True</span>
<span class="sd">                              or from the pythontype otherwise.  False by default</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">datatype_specific</span> <span class="ow">and</span> <span class="n">datatype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No datatype given for a datatype-specific binding&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">datatype</span> <span class="ow">in</span> <span class="n">_toPythonMapping</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;datatype &#39;</span><span class="si">%s</span><span class="s2">&#39; was already bound. Rebinding.&quot;</span> <span class="o">%</span>
                       <span class="n">datatype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">constructor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">constructor</span> <span class="o">=</span> <span class="n">pythontype</span>
    <span class="n">_toPythonMapping</span><span class="p">[</span><span class="n">datatype</span><span class="p">]</span> <span class="o">=</span> <span class="n">constructor</span>
    <span class="k">if</span> <span class="n">datatype_specific</span><span class="p">:</span>
        <span class="n">_SpecificPythonToXSDRules</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">pythontype</span><span class="p">,</span> <span class="n">datatype</span><span class="p">),</span> <span class="n">lexicalizer</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_GenericPythonToXSDRules</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pythontype</span><span class="p">,</span> <span class="p">(</span><span class="n">lexicalizer</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">Variable</span><span class="p">(</span><span class="n">Identifier</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Variable - this is used for querying, or in Formula aware</span>
<span class="sd">    graphs, where Variables can stored in the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Attempted to create variable with empty string as name!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;?&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">text_type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">Variable</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="s2">&quot;rdflib.term.Variable&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;?</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace_manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;?</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="p">(</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),))</span>


<span class="k">class</span> <span class="nc">Statement</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">triple</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="n">subject</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="nb">object</span> <span class="o">=</span> <span class="n">triple</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Class Statement is deprecated, and will be removed in &quot;</span> <span class="o">+</span>
            <span class="s2">&quot;the future. If you use this please let rdflib-dev know!&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="p">((</span><span class="n">subject</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span> <span class="n">context</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Statement</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


<span class="c1"># Nodes are ordered like this</span>
<span class="c1"># See http://www.w3.org/TR/sparql11-query/#modOrderBy</span>
<span class="c1"># we leave &quot;space&quot; for more subclasses of Node elsewhere</span>
<span class="c1"># default-dict to grazefully fail for new subclasses</span>
<span class="n">_ORDERING</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">_ORDERING</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
    <span class="n">BNode</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">Variable</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">:</span> <span class="mi">40</span>
<span class="p">})</span>


<span class="k">def</span> <span class="nf">_isEqualXMLNode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">xml.dom.minidom</span> <span class="kn">import</span> <span class="n">Node</span>

    <span class="k">def</span> <span class="nf">recurse</span><span class="p">():</span>
        <span class="c1"># Recursion through the children</span>
        <span class="c1"># In Python2, the semantics of &#39;map&#39; is such that the check on</span>
        <span class="c1"># length would be unnecessary. In Python 3,</span>
        <span class="c1"># the semantics of map has changed (why, oh why???) and the check</span>
        <span class="c1"># for the length becomes necessary...</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">childNodes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">childNodes</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">oc</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">childNodes</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">childNodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_isEqualXMLNode</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">oc</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># if we got here then everything is fine:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">nodeType</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Node</span><span class="o">.</span><span class="n">DOCUMENT_NODE</span><span class="p">,</span> <span class="n">Node</span><span class="o">.</span><span class="n">DOCUMENT_FRAGMENT_NODE</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">recurse</span><span class="p">()</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="n">ELEMENT_NODE</span><span class="p">:</span>
        <span class="c1"># Get the basics right</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tagName</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">tagName</span> <span class="ow">and</span>
                <span class="n">node</span><span class="o">.</span><span class="n">namespaceURI</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">namespaceURI</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Handle the (namespaced) attributes; the namespace setting key</span>
        <span class="c1"># should be ignored, though</span>
        <span class="c1"># Note that the minidom orders the keys already, so we do not have</span>
        <span class="c1"># to worry about that, which is a bonus...</span>
        <span class="n">n_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">keysNS</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;http://www.w3.org/2000/xmlns/&#39;</span><span class="p">]</span>
        <span class="n">o_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">keysNS</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;http://www.w3.org/2000/xmlns/&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_keys</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_keys</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">n_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">o_keys</span>
                    <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">getAttributeNS</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">getAttributeNS</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># if we got here, the attributes are all right, we can go down</span>
        <span class="c1"># the tree recursively</span>
        <span class="k">return</span> <span class="n">recurse</span><span class="p">()</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">Node</span><span class="o">.</span><span class="n">TEXT_NODE</span><span class="p">,</span> <span class="n">Node</span><span class="o">.</span><span class="n">COMMENT_NODE</span><span class="p">,</span> <span class="n">Node</span><span class="o">.</span><span class="n">CDATA_SECTION_NODE</span><span class="p">,</span>
            <span class="n">Node</span><span class="o">.</span><span class="n">NOTATION_NODE</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="n">PROCESSING_INSTRUCTION_NODE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">target</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="n">ENTITY_NODE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeValue</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">nodeValue</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="n">DOCUMENT_TYPE_NODE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">publicId</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">publicId</span> \
            <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">systemId</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">Id</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># should not happen, in fact</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s1">&#39;I dont know how to compare XML Node type: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Chris Mungall; Nicolas Matentzoglu; Harshad Hegde

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>